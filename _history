{"entries":[{"timestamp":1743751835123,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":131,"diffs":[[1,"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":5776,"diffs":[[1," "]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":212,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]}]},{"timestamp":1743752085675,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":126,"length1":0,"diffs":[[1,"    export enum HexShadeLvl {\n        shade_b = hex`0`,\n        shade_c = hex`0F0D0A0B0E0408060C060B0C0F0B0C0F`,\n        shade_d = hex`0F0B0F0C0C0E0C080F080C0F0F0C0F0F`,\n        shade_e = hex`0F0C0F0F0F0C0F0C0F0C0F0F0F0F0F0F`,\n        shade_f = hex`00000000000000000000000000000000`,\n    }\n    let screenRowsBuffer: Buffer;\n    let maskRowsBuffer: Buffer;\n\n"]]},{"start1":536,"length1":57,"diffs":[[1,"        One = 1,\n"]]},{"start1":577,"length1":57,"diffs":[[1,"        Two = 2,\n"]]},{"start1":620,"length1":57,"diffs":[[1,"        Three = 3,\n"]]},{"start1":664,"length1":57,"diffs":[[1,"        Four = 4\n"]]},{"start1":687,"length1":66,"diffs":[[1,""]]}]}]},{"timestamp":1743752650208,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":126,"length1":342,"diffs":[[1,""]]},{"start1":179,"length1":17,"diffs":[[1,"        shade_1 = hex`0F0D0A0B0E0408060C060B0C0F0B0C0F`,\n"]]},{"start1":260,"length1":17,"diffs":[[1,"        shade_2 = hex`0F0B0F0C0C0E0C080F080C0F0F0C0F0F`,\n"]]},{"start1":343,"length1":19,"diffs":[[1,"        shade_3 = hex`0F0C0F0F0F0C0F0C0F0C0F0F0F0F0F0F`,\n"]]},{"start1":425,"length1":17,"diffs":[[1,"        shade_3 = hex`00000000000000000000000000000000`,\n"]]},{"start1":488,"length1":0,"diffs":[[1,"    let screenRowsBuffer: Buffer;\n    let maskRowsBuffer: Buffer;\n"]]},{"start1":4134,"length1":44,"diffs":[[1,"        switch (shadeLevel) {\n            case 1: palette = shade_1; break;\n            case 2: palette = shade_2; break;\n            case 3: palette = shade_3; break;\n            case 4:\n            default: palette = shade_4; break;\n        }\n"]]},{"start1":4997,"length1":44,"diffs":[[1,"        switch (shadeLevel) {\n            case 1: palette = shade_1; break;\n            case 2: palette = shade_2; break;\n            case 3: palette = shade_3; break;\n            case 4:\n            default: palette = shade_4; break;\n        }\n"]]}]}]},{"timestamp":1743753247684,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":126,"length1":236,"diffs":[[1,"    shade_hex: {[id:number]:Buffer} = {}\n        shade_hex[1] = hex`0F0D0A0B0E0408060C060B0C0F0B0C0F`,\n        shade_hex[2] = hex`0F0B0F0C0C0E0C080F080C0F0F0C0F0F`,\n        shade_hex[3] = hex`0F0C0F0F0F0C0F0C0F0C0F0F0F0F0F0F`,\n         hex`00000000000000000000000000000000`,\n"]]},{"start1":3814,"length1":61,"diffs":[[1,""]]},{"start1":4252,"length1":61,"diffs":[[1,"        palette = shade_buffer[shadeLevel];\n"]]}]}]},{"timestamp":1743753846016,"editorVersion":"2.0.46","changes":[{"type":"edited","filename":"main.blocks","patch":[{"start1":0,"length1":84,"diffs":[[1,"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>"]]}]},{"type":"edited","filename":"main.ts","patch":[{"start1":482,"length1":17,"diffs":[[1,"        One = 0,\n"]]},{"start1":523,"length1":17,"diffs":[[1,"        Two = 1,\n"]]},{"start1":566,"length1":19,"diffs":[[1,"        Three = 2,\n"]]},{"start1":610,"length1":17,"diffs":[[1,"        Four = 3\n"]]},{"start1":3775,"length1":255,"diffs":[[1,"    function shadeitem(shadeLevel: number) {\n        \n"]]},{"start1":4274,"length1":41,"diffs":[[1,"        switch (shadeLevel) {\n            case 1: \n        }\n"]]},{"start1":4953,"length1":41,"diffs":[[1,"        palette = shade_buffer[shadeLevel];\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":212,"length1":44,"diffs":[[1,""]]}]},{"type":"added","filename":"test.ts","value":"// tests go here; this will not be compiled when this package is used as an extension.\n"}]}],"snapshots":[{"timestamp":1743751835122,"editorVersion":"2.0.46","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <variables></variables>\n  <block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block>\n</xml>","main.ts":" ","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-shader\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}},{"timestamp":1743753635963,"editorVersion":"2.0.46","text":{"main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables></variables><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>","main.ts":"namespace SpriteKind {\n    export const Shader = SpriteKind.create();\n}\n\n//% color=\"#9e6eb8\" icon=\"\\uf0eb\"\nnamespace shader {\n    const shade1 = (hex`0F0D0A0B0E0408060C060B0C0F0B0C0F`)\n     shade2 = (hex`0F0B0F0C0C0E0C080F080C0F0F0C0F0F`)\n        shade3 = (hex`0F0C0F0F0F0C0F0C0F0C0F0F0F0F0F0F`)\n        shade4 = (hex`00000000000000000000000000000000`)\n    let screenRowsBuffer: Buffer;\n    let maskRowsBuffer: Buffer;\n\n    export enum ShadeLevel {\n        //% block=\"one\"\n        One = 0,\n        //% block=\"two\"\n        Two = 1,\n        //% block=\"three\"\n        Three = 2,\n        //% block=\"four\"\n        Four = 3\n    }\n\n    class ShaderSprite extends Sprite {\n        protected shadePalette: Buffer;\n        shadeRectangle: boolean;\n\n        constructor(image: Image, shadePalette: Buffer) {\n            super(image);\n            this.shadePalette = shadePalette;\n            this.shadeRectangle = true;\n        }\n\n        __drawCore(camera: scene.Camera) {\n            if (this.isOutOfScreen(camera)) return;\n\n            const ox = (this.flags & sprites.Flag.RelativeToCamera) ? 0 : camera.drawOffsetX;\n            const oy = (this.flags & sprites.Flag.RelativeToCamera) ? 0 : camera.drawOffsetY;\n\n            const l = this.left - ox;\n            const t = this.top - oy;\n\n            if (this.shadeRectangle) {\n                screen.mapRect(l, t, this.image.width, this.image.height, this.shadePalette);\n            }\n            else {\n                shadeImage(screen, l, t, this.image, this.shadePalette);\n            }\n\n\n            if (this.flags & SpriteFlag.ShowPhysics) {\n                const font = image.font5;\n                const margin = 2;\n                let tx = l;\n                let ty = t + this.height + margin;\n                screen.print(`${this.x >> 0},${this.y >> 0}`, tx, ty, 1, font);\n                tx -= font.charWidth;\n                if (this.vx || this.vy) {\n                    ty += font.charHeight + margin;\n                    screen.print(`v${this.vx >> 0},${this.vy >> 0}`, tx, ty, 1, font);\n                }\n                if (this.ax || this.ay) {\n                    ty += font.charHeight + margin;\n                    screen.print(`a${this.ax >> 0},${this.ay >> 0}`, tx, ty, 1, font);\n                }\n            }\n\n            // debug info\n            if (game.debug) {\n                screen.drawRect(\n                    Fx.toInt(this._hitbox.left) - ox,\n                    Fx.toInt(this._hitbox.top) - oy,\n                    Fx.toInt(this._hitbox.width),\n                    Fx.toInt(this._hitbox.height),\n                    1\n                );\n            }\n        }\n    }\n\n\n    function shadeImage(target: Image, left: number, top: number, mask: Image, palette: Buffer) {\n        if (!screenRowsBuffer || screenRowsBuffer.length < target.height) {\n            screenRowsBuffer = pins.createBuffer(target.height);\n        }\n        if (!maskRowsBuffer || maskRowsBuffer.length < target.height) {\n            maskRowsBuffer = pins.createBuffer(mask.height);\n        }\n\n        let targetX = left | 0;\n        let targetY = top | 0;\n        let y: number;\n        let x: number;\n\n        for (x = 0; x < mask.width; x++, targetX++) {\n            if (targetX >= target.width) break;\n            else if (targetX < 0) continue;\n\n            mask.getRows(x, maskRowsBuffer);\n            target.getRows(targetX, screenRowsBuffer);\n\n            for (y = 0, targetY = top | 0; y < mask.height; y++, targetY++) {\n                if (targetY >= target.height) break;\n                else if (targetY < 0) continue;\n\n                if (maskRowsBuffer[y]) screenRowsBuffer[targetY] = palette[screenRowsBuffer[targetY]];\n            }\n            target.setRows(targetX, screenRowsBuffer)\n        }\n    }\n\n    //% blockId=shader_createRectangularShaderSprite\n    //% block=\"create rectangular shader with width $width height $height shade $shadeLevel\"\n    //% shadeLevel.shadow=shader_shadelevel\n    //% width.defl=16\n    //% height.defl=16\n    //% weight=90\n    export function createRectangularShaderSprite(width: number, height: number, shadeLevel: number): Sprite {\n        const scene = game.currentScene();\n\n        let palette: Buffer;\n\n        palette = shade_buffer[shadeLevel];\n        const i = image.create(width, height);\n        i.fill(3);\n\n        const sprite = new ShaderSprite(i, palette)\n        sprite.setKind(SpriteKind.Shader);\n        scene.physicsEngine.addSprite(sprite);\n\n        return sprite\n    }\n\n    //% blockId=shader_createImageShaderSprite\n    //% block=\"create image shader with $image shade $shadeLevel\"\n    //% image.shadow=screen_image_picker\n    //% shadeLevel.shadow=shader_shadelevel\n    //% weight=100\n    export function createImageShaderSprite(image: Image, shadeLevel: number): Sprite {\n        const scene = game.currentScene();\n\n        let palette: Buffer;\n\n        palette = shade_buffer[shadeLevel];\n\n        const sprite = new ShaderSprite(image, palette)\n        sprite.setKind(SpriteKind.Shader);\n        scene.physicsEngine.addSprite(sprite);\n        sprite.shadeRectangle = false;\n\n        return sprite\n    }\n\n    //% blockId=shader_shadelevel\n    //% block=\"$level\"\n    //% shim=TD_ID\n    //% weight=80\n    export function _shadeLevel(level: ShadeLevel): number {\n        return level;\n    }\n}\n","README.md":" ","assets.json":"","pxt.json":"{\n    \"name\": \"arcade-shader\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n"}}],"shares":[],"lastSaveTime":1743754305145}